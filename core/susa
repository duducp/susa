#!/bin/bash

set -euo pipefail

# ============================================================
# CLI - Command Line Interface for Daily Scripts
# ============================================================

# Resolves the symbolic link to find the real directory
CURRENT_SCRIPT="${BASH_SOURCE[0]}"
while [ -L "$CURRENT_SCRIPT" ]; do
    SYMLINK_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT")" && pwd)"
    CURRENT_SCRIPT="$(readlink "$CURRENT_SCRIPT")"
    [[ $CURRENT_SCRIPT != /* ]] && CURRENT_SCRIPT="$SYMLINK_DIR/$CURRENT_SCRIPT"
done

CORE_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT")" && pwd)"
CLI_DIR="$(cd -P "$CORE_DIR/.." && pwd)"
LIB_DIR="$CORE_DIR/lib"
PLUGINS_DIR="$CLI_DIR/plugins"
GLOBAL_CONFIG_FILE="$CORE_DIR/cli.yaml"

# Export variables for child processes (commands)
export CORE_DIR
export CLI_DIR
export LIB_DIR
export PLUGINS_DIR
export GLOBAL_CONFIG_FILE

# ============================================================
# Load Libraries
# ============================================================

source "$LIB_DIR/color.sh"
source "$LIB_DIR/logger.sh"
source "$LIB_DIR/string.sh"
source "$LIB_DIR/os.sh"
source "$LIB_DIR/sudo.sh"

source "$LIB_DIR/internal/yaml.sh"
source "$LIB_DIR/cli.sh"
source "$LIB_DIR/shell.sh"
source "$LIB_DIR/dependencies.sh"

[ -f "$CLI_DIR/config/settings.conf" ] && source "$CLI_DIR/config/settings.conf"

# Validate if the configuration file exists
if [ ! -f "$GLOBAL_CONFIG_FILE" ]; then
    echo "Erro: Arquivo de configuração '$GLOBAL_CONFIG_FILE' não encontrado" >&2
    exit 1
fi

# ============================================================
# Functions
# ============================================================

# Validates or creates the lock file on first execution
validate_or_create_lock_file() {
    local lock_file="$CLI_DIR/susa.lock"

    # Skip check if explicitly requested
    if [ "${SUSA_SKIP_LOCK_CHECK:-}" = "1" ]; then
        return 0
    fi

    # Lock file exists, nothing to do
    if [ -f "$lock_file" ]; then
        return 0
    fi

    log_debug "Lock file não encontrado: $lock_file"
    log_debug "SUSA_SKIP_LOCK_CHECK=${SUSA_SKIP_LOCK_CHECK:-não definido}"
    log_info "Primeira execução detectada. Configurando o Susa CLI..."
    log_info "Gerando arquivo de cache para otimizar o desempenho..."

    log_debug "Chamando comando: SUSA_SKIP_LOCK_CHECK=1 $CORE_DIR/susa self lock"

    # Call the lock command bypassing the check to prevent infinite loop
    if ! SUSA_SKIP_LOCK_CHECK=1 "$CORE_DIR/susa" self lock > /dev/null 2>&1; then
        log_debug "Comando falhou com código de saída: $?"
        log_error "Erro ao gerar arquivo de cache"
        exit 1
    fi

    log_debug "Lock file gerado com sucesso"
    log_success "Configuração concluída! O CLI está pronto para uso."
    echo ""
}

# Display CLI logo with version
show_logo() {
    local version=$(show_number_version)
    cat << LOGO
   _____
  / ____|
 | (___  _   _ ___  __ _
  \___ \| | | / __|/ _' |
  ____) | |_| \__ \ (_| |
 |_____/ \__,_|___/\__,_| ${version}

LOGO
}

# Display global help information
show_help() {
    show_logo

    local description=$(get_yaml_field "$GLOBAL_CONFIG_FILE" "description")
    local categories=$(get_all_categories "$GLOBAL_CONFIG_FILE")

    echo "$description"
    echo ""
    show_usage
    echo ""
    echo -e "${LIGHT_GREEN}Comandos:${NC}"

    for cat in $categories; do
        local cat_desc=$(get_category_info "$GLOBAL_CONFIG_FILE" "$cat" "description")
        printf "  ${LIGHT_CYAN}%-12s${NC} %s\n" "$cat" "$cat_desc"
    done

    echo ""
    echo -e "${LIGHT_GREEN}Opções globais:${NC}"
    printf "  ${LIGHT_CYAN}%-14s${NC} %s\n" "-h, --help" "Mostra esta mensagem de ajuda"
    printf "  ${LIGHT_CYAN}%-14s${NC} %s\n" "-V, --version" "Mostra a versão do CLI"
}

# Print subcategories for a given category
print_subcategories() {
    local category="$1"
    local subcategories="$2"

    if [ -z "$subcategories" ]; then
        return 0
    fi

    echo -e "${LIGHT_GREEN}Subcategories:${NC}"
    for subcat in $subcategories; do
        local subcat_desc=$(get_category_info "$GLOBAL_CONFIG_FILE" "$category/$subcat" "description")
        printf "  ${LIGHT_MAGENTA}%-15s${NC} %s\n" "$subcat" "$subcat_desc"
    done
}

# Format and print a command with its indicators
print_command_line() {
    local category="$1"
    local cmd="$2"
    local cmd_desc="$3"

    local indicators=""

    # Add installed indicator for setup commands
    if [ "$category" = "setup" ]; then
        # Source installations library if not already loaded
        if ! declare -f is_installed &>/dev/null; then
            source "$LIB_DIR/internal/installations.sh" 2>/dev/null || true
        fi

        # Check if software is installed
        if declare -f is_installed &>/dev/null && is_installed "$cmd" 2>/dev/null; then
            indicators="${indicators} ${GREEN}✓${NC}"
        fi
    fi

    # Add plugin indicator if necessary
    if is_plugin_command "$category" "$cmd"; then
        indicators="${indicators} ${GRAY}[plugin]${NC}"
    fi

    # Add dev indicator if necessary
    if is_dev_plugin_command "$category" "$cmd"; then
        indicators="${indicators} ${MAGENTA}[dev]${NC}"
    fi

    # Add sudo indicator if necessary
    if requires_sudo "$GLOBAL_CONFIG_FILE" "$category" "$cmd"; then
        indicators="${indicators} ${YELLOW}[sudo]${NC}"
    fi

    printf "  ${LIGHT_CYAN}%-15s${NC} %s%b\n" "$cmd" "$cmd_desc" "$indicators"
}

# List commands without a group
list_ungrouped_commands() {
    local category="$1"
    local commands="$2"
    local current_os="$3"
    local has_compatible_commands=false

    for cmd in $commands; do
        # Check OS compatibility
        if ! is_command_compatible "$GLOBAL_CONFIG_FILE" "$category" "$cmd" "$current_os"; then
            continue
        fi

        # Skip commands that belong to a group
        local cmd_group=$(get_command_group "$GLOBAL_CONFIG_FILE" "$category" "$cmd")
        if [ -n "$cmd_group" ]; then
            continue
        fi

        has_compatible_commands=true
        local cmd_desc=$(get_command_info "$GLOBAL_CONFIG_FILE" "$category" "$cmd" "description")
        print_command_line "$category" "$cmd" "$cmd_desc"
    done

    [ "$has_compatible_commands" = "true" ] && return 0 || return 1
}

# List grouped commands
list_grouped_commands() {
    local category="$1"
    local commands="$2"
    local current_os="$3"
    local groups="$4"
    local has_compatible_commands=false

    if [ -z "$groups" ]; then
        return 1
    fi

    while IFS= read -r group; do
        [ -z "$group" ] && continue

        echo ""
        echo -e " ${LIGHT_GRAY}$group${NC}"

        for cmd in $commands; do
            # Check OS compatibility
            if ! is_command_compatible "$GLOBAL_CONFIG_FILE" "$category" "$cmd" "$current_os"; then
                continue
            fi

            local cmd_group=$(get_command_group "$GLOBAL_CONFIG_FILE" "$category" "$cmd")

            # List only commands from this group
            if [ "$cmd_group" = "$group" ]; then
                has_compatible_commands=true
                local cmd_desc=$(get_command_info "$GLOBAL_CONFIG_FILE" "$category" "$cmd" "description")
                print_command_line "$category" "$cmd" "$cmd_desc"
            fi
        done
    done <<< "$groups"

    [ "$has_compatible_commands" = "true" ] && return 0 || return 1
}

# List available commands and subcategories for a given category
list_commands() {
    local category="$1"
    local categories=$(get_all_categories "$GLOBAL_CONFIG_FILE")

    # Check if it is a top-level category
    local is_top_level=false
    if echo "$categories" | grep -q "^${category}$"; then
        is_top_level=true
    fi

    # If not top-level, validate if directory exists
    if [ "$is_top_level" = false ]; then
        if [ ! -d "$CLI_DIR/commands/$category" ] && [ ! -d "$CLI_DIR/plugins"/*/"$category" 2>/dev/null ]; then
            log_error "Categoria '$category' não encontrada"
            return 1
        fi
    fi

    local category_desc=$(get_category_info "$GLOBAL_CONFIG_FILE" "$category" "description")
    local current_os=$(get_simple_os)
    local commands=$(get_category_commands "$category" "$current_os")
    local subcategories=$(get_category_subcategories "$category")

    echo "$category_desc"
    echo ""
    show_usage "$category"
    echo ""

    # Print subcategories first
    print_subcategories "$category" "$subcategories"

    # Add spacing between subcategories and commands if both exist
    if [ -n "$subcategories" ] && [ -n "$commands" ]; then
        echo ""
    fi

    # List commands
    if [ -n "$commands" ]; then
        echo -e "${LIGHT_GREEN}Comandos:${NC}"

        # List commands without a group
        list_ungrouped_commands "$category" "$commands" "$current_os"
        local has_ungrouped=$?

        # List grouped commands
        local groups=$(get_category_groups "$GLOBAL_CONFIG_FILE" "$category" "$current_os")
        list_grouped_commands "$category" "$commands" "$current_os" "$groups"
        local has_grouped=$?

        # Show message if no compatible commands found
        if [ $has_ungrouped -ne 0 ] && [ $has_grouped -ne 0 ] && [ -z "$subcategories" ]; then
            echo -e "  ${GRAY}Nenhum comando ou subcategoria disponível${NC}"
        fi
    fi
}

# Validate command exists and is compatible with current OS
validate_command() {
    local category="$1"
    local command="$2"
    local current_os="$3"

    # Find command config
    local config_file=$(find_command_config "$category" "$command")

    if [ -z "$config_file" ]; then
        log_error "Comando '$command' não encontrado na categoria '$category'"
        echo ""
        list_commands "$category"
        exit 1
    fi

    # Check OS compatibility
    if ! is_command_compatible "$GLOBAL_CONFIG_FILE" "$category" "$command" "$current_os"; then
        log_error "Comando '$command' não é compatível com o sistema operacional atual ($current_os)"
        exit 1
    fi

    echo "$config_file"
}

# Check if help was requested for the command
check_and_show_command_help() {
    local script_path="$1"
    shift

    for arg in "$@"; do
        if [ "$arg" = "--help" ] || [ "$arg" = "-h" ]; then
            # Check if show_help function exists without executing the script
            if grep -q "^show_help()" "$script_path" 2>/dev/null; then
                export SUSA_SHOW_HELP_CALLED=true
                source "$script_path"
                show_help
                unset SUSA_SHOW_HELP_CALLED
            fi
            exit 0
        fi
    done
}

# Execute a command with its arguments
execute_command() {
    local category="$1"
    local command="$2"
    shift 2

    local current_os=$(get_simple_os)

    # Validate command exists and is compatible
    local config_file=$(validate_command "$category" "$command" "$current_os")

    # Get entrypoint name and build path
    local script_name=$(get_command_info "$GLOBAL_CONFIG_FILE" "$category" "$command" "entrypoint")

    # Check if this is a plugin command (has source in lock)
    local plugin_source=""
    if has_valid_lock_file; then
        local lock_file="$CLI_DIR/susa.lock"
        plugin_source=$(yq eval ".commands[] | select(.category == \"$category\" and .name == \"$command\" and .plugin != null) | .plugin.source" "$lock_file" 2>/dev/null | head -1)
    fi

    # Build script path - use plugin source if available
    local script_path=""
    if [ -n "$plugin_source" ] && [ "$plugin_source" != "null" ]; then
        # Plugin with source - use source from lock
        script_path="$plugin_source/$category/$command/$script_name"
    else
        # Regular command
        local command_dir=$(dirname "$config_file")
        script_path="$command_dir/$script_name"
    fi

    if [ ! -f "$script_path" ]; then
        log_error "Script '$script_name' não encontrado em $(dirname "$script_path")/"
        exit 1
    fi

    # Check if help was requested for the command
    check_and_show_command_help "$script_path" "$@"

    # Check if sudo is required and notify user
    if requires_sudo "$GLOBAL_CONFIG_FILE" "$category" "$command"; then
        required_sudo
    fi

    source "$script_path" "$@"
}

# Main entry point
main() {
    # Validate or create lock file on first execution
    validate_or_create_lock_file

    # No arguments - show help
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    # Global options
    case "$1" in
        -h|--help|help)
            show_help
            exit 0
            ;;
        -V|--version|version)
            show_version
            exit 0
            ;;
    esac

    # Build category/subcategory path
    local category="$1"
    local remaining_args=("${@:2}")

    # Check if there are more arguments that could be subcategories
    while [ ${#remaining_args[@]} -gt 0 ]; do
        local next_arg="${remaining_args[0]}"

        # If it's help, show help for current category
        if [ "$next_arg" = "help" ]; then
            list_commands "$category"
            exit 0
        fi

        # Try to see if it's a subcategory
        local subcategories=$(get_category_subcategories "$category")
        if echo "$subcategories" | grep -q "^${next_arg}$"; then
            # It is a subcategory, add to path
            category="$category/$next_arg"
            remaining_args=("${remaining_args[@]:1}")
        else
            # Not a subcategory, must be a command
            break
        fi
    done

    # If no arguments remain, list commands/subcategories for the category
    if [ ${#remaining_args[@]} -eq 0 ]; then
        list_commands "$category"
        exit 0
    fi

    # The next argument is the command
    local command="${remaining_args[0]}"
    local command_args=("${remaining_args[@]:1}")

    # Execute the command
    execute_command "$category" "$command" "${command_args[@]}"
}

main "$@"
