#!/bin/bash

set -euo pipefail

# ============================================================
# CLI - Command Line Interface for Daily Scripts
# ============================================================

# Resolves the symbolic link to find the real directory
CURRENT_SCRIPT="${BASH_SOURCE[0]}"
while [ -L "$CURRENT_SCRIPT" ]; do
    SYMLINK_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT")" && pwd)"
    CURRENT_SCRIPT="$(readlink "$CURRENT_SCRIPT")"
    [[ $CURRENT_SCRIPT != /* ]] && CURRENT_SCRIPT="$SYMLINK_DIR/$CURRENT_SCRIPT"
done

CORE_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT")" && pwd)"
CLI_DIR="$(cd -P "$CORE_DIR/.." && pwd)"
LIB_DIR="$CORE_DIR/lib"
PLUGINS_DIR="$CLI_DIR/plugins"
GLOBAL_CONFIG_FILE="$CORE_DIR/cli.json"

# Export variables for child processes (commands)
export CORE_DIR
export CLI_DIR
export LIB_DIR
export PLUGINS_DIR
export GLOBAL_CONFIG_FILE

# ============================================================
# Load Libraries
# ============================================================

# Core libraries (always needed)
source "$LIB_DIR/color.sh"
source "$LIB_DIR/logger.sh"
source "$LIB_DIR/os.sh"

# Config system (needs cache first)
source "$LIB_DIR/internal/config.sh"
source "$LIB_DIR/cli.sh"

# Display and execution libraries
source "$LIB_DIR/internal/display.sh"
source "$LIB_DIR/internal/executor.sh"

# Lazy-loaded libraries (only when needed)
# string.sh, sudo.sh, shell.sh, dependencies.sh

[ -f "$CLI_DIR/config/settings.conf" ] && source "$CLI_DIR/config/settings.conf"

# Load cache for fast startup
cache_load 2> /dev/null || true

# Validate if the configuration file exists
if [ ! -f "$GLOBAL_CONFIG_FILE" ]; then
    echo "Erro: Arquivo de configuração '$GLOBAL_CONFIG_FILE' não encontrado" >&2
    exit 1
fi

# ============================================================
# Functions
# ============================================================

# Validates or creates the lock file on first execution
validate_or_create_lock_file() {
    local lock_file="$CLI_DIR/susa.lock"

    # Skip check if explicitly requested
    if [ "${SUSA_SKIP_LOCK_CHECK:-}" = "1" ]; then
        return 0
    fi

    # Lock file exists, nothing to do
    if [ -f "$lock_file" ]; then
        return 0
    fi

    log_info "Primeira execução detectada. Configurando o Susa CLI..."
    log_info "Gerando arquivo de cache para otimizar o desempenho..."

    # Call the lock command bypassing the check to prevent infinite loop
    local lock_output
    if ! lock_output=$(SUSA_SKIP_LOCK_CHECK=1 "$CORE_DIR/susa" self lock 2>&1); then
        log_error "Erro ao gerar arquivo de cache"
        exit 1
    fi

    log_success "Configuração concluída! O CLI está pronto para uso."
    echo ""
}

# Display global help information (alias for show_global_help from display.sh)
show_help() {
    show_global_help
}

# List commands for a category (alias for display_category_help from display.sh)
list_commands() {
    display_category_help "$@"
}

# Main entry point
main() {
    # Validate or create lock file on first execution
    validate_or_create_lock_file

    # No arguments - show help
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    # Check for global flags before processing
    local args=("$@")
    local filtered_args=()

    for arg in "${args[@]}"; do
        if [ "$arg" = "--group" ]; then
            export SUSA_GROUP=1
        else
            filtered_args+=("$arg")
        fi
    done

    # Reset arguments with filtered list
    set -- "${filtered_args[@]}"

    # No arguments after filtering - show help
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    # Global options
    case "$1" in
        -h | --help | help)
            show_help
            exit 0
            ;;
        -V | --version | version)
            show_version
            exit 0
            ;;
    esac

    # Build category/subcategory path
    local category="$1"
    local remaining_args=("${@:2}")

    # Check if there are more arguments that could be subcategories
    while [ ${#remaining_args[@]} -gt 0 ]; do
        local next_arg="${remaining_args[0]}"

        # If it's help, show help for current category
        if [ "$next_arg" = "help" ]; then
            list_commands "$category"
            exit 0
        fi

        # Try to see if it's a subcategory
        local subcategories=$(get_category_subcategories "$category")
        if echo "$subcategories" | grep -q "^${next_arg}$"; then
            # It is a subcategory, add to path
            category="$category/$next_arg"
            remaining_args=("${remaining_args[@]:1}")
        else
            # Not a subcategory, check if it's an option for the category script
            if [[ "$next_arg" =~ ^- ]]; then
                # It's an option (starts with -), check if category has a script
                if category_has_entrypoint "$category"; then
                    local script_path=$(get_category_entrypoint_path "$category")
                    if [ -n "$script_path" ] && [ -f "$script_path" ]; then
                        # Execute category script with all remaining arguments
                        source "$script_path" "${remaining_args[@]}"
                        exit $?
                    fi
                fi
            fi
            # Not a subcategory or option, must be a command
            break
        fi
    done

    # If no arguments remain, list commands/subcategories for the category
    if [ ${#remaining_args[@]} -eq 0 ]; then
        list_commands "$category"
        exit 0
    fi

    # The next argument is the command
    local command="${remaining_args[0]}"
    local command_args=("${remaining_args[@]:1}")

    # Execute the command
    execute_command "$category" "$command" "${command_args[@]}"
}

main "$@"
