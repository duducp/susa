#!/bin/bash

set -euo pipefail

# ============================================================
# CLI - Command Line Interface for Daily Scripts
# ============================================================

# Resolves the symbolic link to find the real directory
CURRENT_SCRIPT="${BASH_SOURCE[0]}"
while [ -L "$CURRENT_SCRIPT" ]; do
    SYMLINK_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT")" && pwd)"
    CURRENT_SCRIPT="$(readlink "$CURRENT_SCRIPT")"
    [[ $CURRENT_SCRIPT != /* ]] && CURRENT_SCRIPT="$SYMLINK_DIR/$CURRENT_SCRIPT"
done

CORE_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT")" && pwd)"
CLI_DIR="$(cd -P "$CORE_DIR/.." && pwd)"
LIB_DIR="$CORE_DIR/lib"
PLUGINS_DIR="$CLI_DIR/plugins"
GLOBAL_CONFIG_FILE="$CORE_DIR/cli.json"

# Export variables for child processes (commands)
export CORE_DIR
export CLI_DIR
export LIB_DIR
export PLUGINS_DIR
export GLOBAL_CONFIG_FILE

# Constants
readonly EXEC_ENTRYPOINT_MARKER="__EXEC_ENTRYPOINT__"

# ============================================================
# Dependency Checking
# ============================================================

# Check and prompt for missing dependencies
check_dependencies() {
    # Skip check if explicitly requested (useful for CI/CD)
    if [ "${SUSA_SKIP_DEPS_CHECK:-}" = "1" ]; then
        return 0
    fi

    local missing_deps=()
    local install_commands=()
    local reasons=()

    # Check Bash version (requires 4+ for associative arrays)
    if ((BASH_VERSINFO[0] < 4)); then
        missing_deps+=("bash")
        reasons+=("Bash 4.0+ é necessário para arrays associativos usados pelo sistema de cache")

        if [[ "$OS_TYPE" == "macos" ]]; then
            install_commands+=("brew install bash && sudo bash -c 'echo /opt/homebrew/bin/bash >> /etc/shells' && chsh -s /opt/homebrew/bin/bash")
        else
            install_commands+=("sudo apt update && sudo apt install -y bash")
        fi
    fi

    # Check jq (required for JSON parsing)
    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
        reasons+=("jq é necessário para processar arquivos JSON (cache, configurações, plugins)")

        if [[ "$OS_TYPE" == "macos" ]]; then
            install_commands+=("brew install jq")
        elif [[ "$OS_TYPE" == "debian" ]]; then
            install_commands+=("sudo apt update && sudo apt install -y jq")
        elif [[ "$OS_TYPE" == "fedora" ]]; then
            install_commands+=("sudo dnf install -y jq")
        else
            install_commands+=("Instale jq manualmente para seu sistema")
        fi
    fi

    # If no missing dependencies, return success
    if [ ${#missing_deps[@]} -eq 0 ]; then
        return 0
    fi

    # Display missing dependencies
    echo ""
    log_error "Dependências faltando"
    echo ""

    for i in "${!missing_deps[@]}"; do
        local dep="${missing_deps[$i]}"
        local reason="${reasons[$i]}"
        local install_cmd="${install_commands[$i]}"

        echo -e "${LIGHT_RED}✗ ${dep}${NC}"
        echo -e "  ${LIGHT_GRAY}Motivo: ${reason}${NC}"
        echo -e "  ${LIGHT_CYAN}Comando: ${install_cmd}${NC}"
        echo ""
    done

    # Ask user if they want to install
    echo -e "${LIGHT_YELLOW}Deseja instalar as dependências agora? (s/N)${NC}"
    read -r response

    if [[ "$response" =~ ^[SsYy]$ ]]; then
        echo ""
        log_info "Instalando dependências..."
        echo ""

        for i in "${!missing_deps[@]}"; do
            local dep="${missing_deps[$i]}"
            local install_cmd="${install_commands[$i]}"

            log_info "Instalando ${dep}..."
            if eval "$install_cmd"; then
                log_success "✓ ${dep} instalado com sucesso!"
            else
                log_error "✗ Falha ao instalar ${dep}"
                echo ""
                log_warning "Por favor, instale manualmente:"
                echo "  $install_cmd"
            fi
            echo ""
        done

        # Special message for Bash upgrade
        if [[ " ${missing_deps[*]} " =~ " bash " ]]; then
            echo ""
            log_warning "⚠ Bash foi atualizado!"
            echo ""
            echo "Para usar a nova versão:"
            echo "  1. Feche este terminal"
            echo "  2. Abra um novo terminal"
            echo "  3. Execute: bash --version (deve mostrar 4.x ou superior)"
            echo ""
            exit 0
        fi

        log_success "Dependências instaladas! Execute o comando novamente."
        exit 0
    else
        echo ""
        log_warning "Instalação cancelada."
        echo ""
        log_info "O SUSA CLI requer estas dependências para funcionar corretamente."
        log_info "Instale-as manualmente e tente novamente."
        echo ""
        exit 1
    fi
}

# ============================================================
# Load Libraries
# ============================================================

# Core libraries (always needed)
source "$LIB_DIR/color.sh"
source "$LIB_DIR/logger.sh"
source "$LIB_DIR/os.sh"
source "$LIB_DIR/cache.sh"
source "$LIB_DIR/context.sh"

# Essential internal libraries (loaded automatically for all commands)
source "$LIB_DIR/internal/lock.sh"

# Config system (uses lock.sh internally)
source "$LIB_DIR/internal/config.sh"
source "$LIB_DIR/cli.sh"

# Display and execution libraries
source "$LIB_DIR/internal/display.sh"
source "$LIB_DIR/internal/executor.sh"

# Lazy-loaded libraries (only when needed)
# string.sh, sudo.sh, shell.sh, dependencies.sh

[ -f "$CLI_DIR/config/settings.conf" ] && source "$CLI_DIR/config/settings.conf"

# Check dependencies before proceeding
check_dependencies

# Load cache for fast startup (only if lock exists)
if [ -f "$CLI_DIR/susa.lock" ]; then
    cache_load 2> /dev/null || true
fi

# Validate if the configuration file exists
if [ ! -f "$GLOBAL_CONFIG_FILE" ]; then
    echo "Erro: Arquivo de configuração '$GLOBAL_CONFIG_FILE' não encontrado" >&2
    exit 1
fi

# ============================================================
# Functions
# ============================================================

# Try to execute custom show_help from script
# Returns 0 if custom help was executed, 1 otherwise
_try_execute_custom_help() {
    local script_path="$1"

    if [ ! -f "$script_path" ] || ! grep -q "^show_help()" "$script_path" 2> /dev/null; then
        return 1
    fi

    (
        export CORE_DIR LIB_DIR CLI_DIR
        # shellcheck disable=SC2030,SC2031
        export SUSA_SHOW_HELP=1
        source "$script_path" 2> /dev/null || true
        if declare -f show_help > /dev/null 2>&1; then
            show_help
            exit 0
        fi
    ) && exit 0

    return 1
}

# Try to load script and execute display_help with show_complement_help
_load_and_display_help() {
    local script_path="$1"

    if [ ! -f "$script_path" ]; then
        display_help
        exit 0
    fi

    # Load script and call display_help in the same context
    (
        export CORE_DIR LIB_DIR CLI_DIR
        export SUSA_SHOW_HELP=1

        # Source the script to make show_help and show_complement_help available
        source "$script_path" 2> /dev/null || true

        # Now call display_help which will detect the functions
        display_help
    )
    exit $?
}

# Validates or creates the lock file on first execution
validate_or_create_lock_file() {
    local lock_file="$CLI_DIR/susa.lock"

    # Skip check if explicitly requested
    if [ "${SUSA_SKIP_LOCK_CHECK:-}" = "1" ]; then
        return 0
    fi

    # Lock file exists, nothing to do
    if [ -f "$lock_file" ]; then
        return 0
    fi

    log_info "Primeira execução detectada. Configurando o Susa CLI..."
    log_info "Gerando arquivo de cache para otimizar o desempenho..."

    # Call the lock command bypassing the check to prevent infinite loop
    local lock_output
    if ! lock_output=$(SUSA_SKIP_LOCK_CHECK=1 "$CORE_DIR/susa" self lock 2>&1); then
        log_error "Erro ao gerar arquivo de cache"
        echo "$lock_output" >&2
        exit 1
    fi

    log_success "Configuração concluída! O CLI está pronto para uso."
    echo ""
}

# Process global flags and filter arguments
process_global_flags() {
    local -n _args_ref=$1
    local -n _filtered_ref=$2

    # Initialize verbosity level
    export VERBOSE_LEVEL=0

    # First pass: check if --quiet is present (takes priority)
    local has_quiet=false
    for arg in "${_args_ref[@]}"; do
        if [[ "$arg" == "-q" ]] || [[ "$arg" == "--quiet" ]]; then
            has_quiet=true
            break
        fi
    done

    # Process each flag
    for arg in "${_args_ref[@]}"; do
        case "$arg" in
            --group)
                export SUSA_GROUP=1
                ;;
            -q | --quiet)
                export VERBOSE_LEVEL=0
                export SILENT=1
                unset DEBUG TRACE
                ;;
            -vvv | --verbose=3)
                if [ "$has_quiet" = false ]; then
                    export VERBOSE_LEVEL=3
                    export DEBUG=1
                    export TRACE=1
                    log_debug "Modo trace ativado (nível 3)"
                fi
                ;;
            -vv | --verbose=2)
                if [ "$has_quiet" = false ]; then
                    export VERBOSE_LEVEL=2
                    export DEBUG=1
                    log_debug "Modo debug detalhado ativado (nível 2)"
                fi
                ;;
            -v | --verbose | --verbose=1)
                if [ "$has_quiet" = false ]; then
                    export VERBOSE_LEVEL=1
                    export DEBUG=1
                    log_debug "Modo verbose ativado (nível 1)"
                fi
                ;;
            *)
                # Keep all other arguments (including --help)
                _filtered_ref+=("$arg")
                ;;
        esac
    done
}

# Resolve category path from arguments
resolve_category_path() {
    local category="$1"
    shift
    local remaining_args=("$@")

    # Check if there are more arguments that could be subcategories
    while [ ${#remaining_args[@]} -gt 0 ]; do
        local next_arg="${remaining_args[0]}"

        # If it's help, show help for current category
        if [ "$next_arg" = "help" ]; then
            display_help
            exit 0
        fi

        # Try to see if it's a subcategory
        local subcategories=$(get_category_subcategories "$category")
        if echo "$subcategories" | grep -q "^${next_arg}$"; then
            # It is a subcategory, add to path
            category="$category/$next_arg"
            remaining_args=("${remaining_args[@]:1}")
        else
            # Not a subcategory - check if it's an option (starts with -)
            if [[ "$next_arg" =~ ^- ]]; then
                # It's an option - check if category has a script to handle it
                if category_has_entrypoint "$category"; then
                    # Return special marker to indicate entrypoint execution
                    echo "$EXEC_ENTRYPOINT_MARKER"
                    echo "$category"
                    printf '%s\n' "${remaining_args[@]}"
                    return 0
                fi
            fi

            # Check if it looks like a command (not an option and category has commands)
            if ! category_has_entrypoint "$category"; then
                # Not a subcategory and no entrypoint, must be a command
                break
            fi

            # Category has entrypoint but arg doesn't start with -
            # Could be a command or argument to entrypoint
            # If command exists, treat as command; otherwise pass to entrypoint
            local commands=$(get_category_commands "$category" "$(get_simple_os)")
            if echo "$commands" | grep -q "^${next_arg}$"; then
                # It's a command
                break
            fi

            # Not a command, pass all remaining args to entrypoint
            echo "$EXEC_ENTRYPOINT_MARKER"
            echo "$category"
            printf '%s\n' "${remaining_args[@]}"
            return 0
        fi
    done

    # After resolving full category path, check if it has an entrypoint
    # This handles cases like "susa setup dbeaver" where dbeaver is a subcategory with entrypoint
    if [ ${#remaining_args[@]} -eq 0 ] && category_has_entrypoint "$category"; then
        # Return special marker to indicate entrypoint execution
        echo "$EXEC_ENTRYPOINT_MARKER"
        echo "$category"
        return 0
    fi

    # Return category and remaining args (space-separated)
    echo "$category"
    printf '%s\n' "${remaining_args[@]}"
}

# Handle global commands that should show info and exit immediately
# Only processes: help, --help, -h, version, --version, -V
_handle_global_commands() {
    local first_arg="$1"

    case "$first_arg" in
        -h | --help)
            show_global_help
            exit 0
            ;;
        -V | --version)
            show_version
            exit 0
            ;;
    esac
}

# Handle execution of category entrypoint
_handle_entrypoint_execution() {
    local category="$1"
    shift
    local entrypoint_args=("$@")

    # Check if --help was requested
    for arg in "${entrypoint_args[@]}"; do
        if [ "$arg" = "--help" ] || [ "$arg" = "-h" ]; then
            initialize_command_context "$category" "" "${entrypoint_args[@]}"
            display_help
            exit 0
        fi
    done

    # Initialize context for category with entrypoint
    initialize_command_context "$category" "" "${entrypoint_args[@]}"

    # If no args, show category help instead of executing entrypoint
    if [ ${#entrypoint_args[@]} -eq 0 ]; then
        display_help
        exit 0
    fi

    # Execute category script with args
    local script_path=$(get_category_entrypoint_path "$category")
    if [ -n "$script_path" ] && [ -f "$script_path" ]; then
        (
            set -- "${entrypoint_args[@]}"
            source "$script_path" "$@"
        )
        exit $?
    fi

    log_error "Entrypoint não encontrado para categoria: $category"
    exit 1
}

# Handle category display (with or without entrypoint)
_handle_category_display() {
    local category="$1"

    # Check if category has entrypoint
    if category_has_entrypoint "$category"; then
        initialize_command_context "$category" ""

        local script_path=$(get_category_entrypoint_path "$category")
        if [ -n "$script_path" ] && [ -f "$script_path" ]; then
            # Try custom show_help
            _try_execute_custom_help "$script_path" && return

            # No custom show_help, execute entrypoint normally
            (source "$script_path")
            exit $?
        fi

        log_error "Entrypoint não encontrado para categoria: $category"
        exit 1
    fi

    # No entrypoint - list category commands
    initialize_command_context "$category" ""
    display_help
    exit 0
}

# Handle command help display
_handle_command_help() {
    local category="$1"
    local command="$2"
    shift 2
    local command_args=("$@")

    initialize_command_context "$category" "$command" "${command_args[@]}"

    # Find command script
    local config_file=$(find_command_config "$category" "$command")
    if [ -n "$config_file" ]; then
        local command_dir=$(dirname "$config_file")
        local entrypoint=$(get_config_field "$config_file" "entrypoint")
        local script_path="$command_dir/$entrypoint"

        # Try custom show_help
        if [ -f "$script_path" ]; then
            _try_execute_custom_help "$script_path" && return

            # No custom show_help, load script and try show_complement_help
            _load_and_display_help "$script_path"
            return
        fi
    fi

    # No config file or script, use standard help
    display_help
    exit 0
}

# Main entry point
main() {
    # Validate or create lock file on first execution
    validate_or_create_lock_file

    # No arguments - show global help
    [ $# -eq 0 ] && show_global_help && exit 0

    # Process global flags and filter arguments
    local args=("$@")
    process_global_flags args filtered_args

    # No arguments after filtering - show global help
    [ ${#filtered_args[@]} -eq 0 ] && show_global_help && exit 0

    # Handle global commands (help/version)
    _handle_global_commands "${filtered_args[0]}"

    # Resolve category path and remaining arguments
    local result_output
    result_output=$(resolve_category_path "${filtered_args[@]}")

    # Read result into array
    local result=()
    while IFS= read -r line; do
        result+=("$line")
    done <<< "$result_output"

    local marker="${result[0]}"

    # Check if we need to execute category entrypoint
    if [ "$marker" = "$EXEC_ENTRYPOINT_MARKER" ]; then
        local category="${result[1]}"
        local entrypoint_args=("${result[@]:2}")
        _handle_entrypoint_execution "$category" "${entrypoint_args[@]}"
    fi

    # Normal flow: category and command
    local category="${result[0]}"
    local remaining_args=("${result[@]:1}")

    # No command specified
    if [ ${#remaining_args[@]} -eq 0 ]; then
        _handle_category_display "$category"
    fi

    # Extract command and its arguments
    local command="${remaining_args[0]:-}"

    # If no command was extracted, show help
    if [ -z "$command" ]; then
        initialize_command_context "$category" ""
        display_help
        exit 0
    fi

    local command_args=("${remaining_args[@]:1}")

    # Check if --help was requested (global flag handling)
    for arg in "${command_args[@]}"; do
        if [ "$arg" = "--help" ] || [ "$arg" = "-h" ]; then
            _handle_command_help "$category" "$command" "${command_args[@]}"
        fi
    done

    # Initialize context before executing command
    initialize_command_context "$category" "$command" "${command_args[@]}"

    # Execute the command
    execute_command "$category" "$command" "${command_args[@]}"
}

main "$@"
